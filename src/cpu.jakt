import system { System }

class CPU {
    a: u8
    x: u8
    y: u8
    public pc: u16
    s: u8
    // flags
    carry: bool
    zero: bool
    interrupt_disable: bool
    decimal: bool
    break_flag: bool
    overflow: bool
    negative: bool
    system: System
    clock: u64
    opcode: u8
    opname: String

    public function init(system: System) throws -> CPU {
        let reset_vector = 0xc000u16//system.read_word(address: 0xfffc)

        return CPU (
            a: 0
            x: 0
            y: 0
            pc: reset_vector
            s: 0xfd
            carry: false
            zero: false
            interrupt_disable: true
            decimal: false
            break_flag: false
            overflow: false
            negative: false
            system
            clock: 0
            opcode: 0x80
            opname: ""
        )
    }

    public function tick(mut this) throws {
        if (.clock > 0) {
            .clock -= 1
            return
        }

        if (.clock == 0) {
            let old_pc = .pc
            .opname = "UNKNOWN";
            .opcode = .system.read_byte(address: .pc)

            if (.opcode == 0x4c or .opcode == 0x6c) {
                .jmp(opcode: .opcode)
                .opname = "JMP"
            }
            else if (.opcode == 0x78) {
                .sei()
                .opname = "SEI"
            }
            else if (.opcode == 0xf8) {
                .sed()
                .opname = "SED"
            }
            else if (.opcode == 0xd8) {
                .cld()
                .opname = "CLD"
            }
            else if (.opcode == 0x08) {
                .php()
                .opname = "PHP"
            }
            else if (.opcode == 0x68) {
                .pla()
                .opname = "PLA"
            }
            else if (.opcode == 0x48) {
                .pha()
                .opname = "PHA"
            }
            else if (.opcode == 0x28) {
                .plp()
                .opname = "PLP"
            }
            else if (.opcode == 0xa2 or .opcode == 0xa6 or .opcode == 0xb6 or .opcode == 0xbe or .opcode == 0xae) {
                .ldx(opcode: .opcode)
                .opname = "LDX"
            }
            else if (.opcode == 0xa0 or .opcode == 0xa4 or .opcode == 0xb4 or .opcode == 0xac or .opcode == 0xbc) {
                .ldy(opcode: .opcode)
                .opname = "LDY"
            }
            else if (.opcode == 0x9a) {
                .txs()
                .opname = "TXS"
            }
            else if (.opcode == 0xa9 or .opcode == 0xa5 or .opcode == 0xb5 or .opcode == 0xa1 or .opcode == 0xb1 or .opcode == 0xad or .opcode == 0xbd or .opcode == 0xb9) {
                .lda(opcode: .opcode)
                .opname = "LDA"
            }
            else if (.opcode == 0x10) {
                .bpl()
                .opname = "BPL"
            }
            else if (.opcode == 0x86 or .opcode == 0x96 or .opcode == 0x8e) {
                .stx(opcode: .opcode)
                .opname = "STX"
            }
            else if (.opcode == 0x20) {
                .jsr()
                .opname = "JSR"
            }
            else if (.opcode == 0x60) {
                .rts()
                .opname = "RTS"
            }
            else if (.opcode == 0x85 or .opcode == 0x95 or .opcode == 0x81 or .opcode == 0x91 or .opcode == 0x8d or .opcode == 0x9d or .opcode == 0x99) {
                .sta(opcode: .opcode)
                .opname = "STA"
            }
            else if (.opcode == 0x00) {
                .brk()
                .opname = "BRK"
            }
            else if (.opcode == 0x40) {
                .rti()
                .opname = "RTI"
            }
            else if (.opcode == 0x8e) {
                .stx(opcode: .opcode)
                .opname = "STX"
            }
            else if (.opcode == 0x84 or .opcode == 0x94 or .opcode == 0x8c) {
                .sty(opcode: .opcode)
                .opname = "STY"
            }
            else if (.opcode == 0xaa) {
                .tax()
                .opname = "TAX"
            }
            else if (.opcode == 0x8a) {
                .txa()
                .opname = "TXA"
            }
            else if (.opcode == 0x98) {
                .tya()
                .opname = "TYA"
            }
            else if (.opcode == 0xa8) {
                .tay()
                .opname = "TAY"
            }
            else if (.opcode == 0xba) {
                .tsx()
                .opname = "TSX"
            }
            else if (.opcode == 0x9a) {
                .txs()
                .opname = "TXS"
            }
            else if (.opcode == 0x85) {
                .sta(opcode: .opcode)
                .opname = "STA"
            }
            else if (.opcode == 0x24 or .opcode == 0x2c) {
                .bit(opcode: .opcode)
                .opname = "BIT"
            }
            else if (.opcode == 0x30) {
                .bmi()
                .opname = "BMI"
            }
            else if (.opcode == 0x90) {
                .bcc()
                .opname = "BCC"
            }
            else if (.opcode == 0xb0) {
                .bcs()
                .opname = "BCS"
            }
            else if (.opcode == 0xf0) {
                .beq()
                .opname = "BEQ"
            }
            else if (.opcode == 0xd0) {
                .bne()
                .opname = "BNE"
            }
            else if (.opcode == 0x50) {
                .bvc()
                .opname = "BVC"
            }
            else if (.opcode == 0x70) {
                .bvs()
                .opname = "BVS"
            }
            else if (.opcode == 0x18) {
                .clc()
                .opname = "CLC"
            }
            else if (.opcode == 0x58) {
                .cli()
                .opname = "CLI"
            }
            else if (.opcode == 0xb8) {
                .clv()
                .opname = "CLV"
            }
            else if (.opcode == 0xe0 or .opcode == 0xe4 or .opcode == 0xec) {
                .cpx(opcode: .opcode)
                .opname = "CPX"
            }
            else if (.opcode == 0xc0 or .opcode == 0xc4 or .opcode == 0xcc) {
                .cpy(opcode: .opcode)
                .opname = "CPY"
            }
            else if (.opcode == 0xc6 or .opcode == 0xd6 or .opcode == 0xce or .opcode == 0xde) {
                .dec(opcode: .opcode)
                .opname = "DEC"
            }
            else if (.opcode == 0xca) {
                .dex()
                .opname = "DEX"
            }
            else if (.opcode == 0x88) {
                .dey()
                .opname = "DEY"
            }
            else if (.opcode == 0xe6 or .opcode == 0xf6 or .opcode == 0xee or .opcode == 0xfe) {
                .inc(opcode: .opcode)
                .opname = "INC"
            }
            else if (.opcode == 0xe8) {
                .inx()
                .opname = "INX"
            }
            else if (.opcode == 0xc8) {
                .iny()
                .opname = "INY"
            }
            else if (.opcode == 0x0a or .opcode == 0x06 or .opcode == 0x16 or .opcode == 0x0e or .opcode == 0x1e) {
                .asl(opcode: .opcode)
                .opname = "ASL"
            }
            else if (.opcode == 0x2a or .opcode == 0x26 or .opcode == 0x36 or .opcode == 0x2e or .opcode == 0x3e) {
                .rol(opcode: .opcode)
                .opname = "ROL"
            }
            else if (.opcode == 0x4a or .opcode == 0x46 or .opcode == 0x56 or .opcode == 0x4e or .opcode == 0x5e) {
                .lsr(opcode: .opcode)
                .opname = "LSR"
            }
            else if (.opcode == 0x6a or .opcode == 0x66 or .opcode == 0x76 or .opcode == 0x6e or .opcode == 0x7e) {
                .ror(opcode: .opcode)
                .opname = "ROR"
            }
            else if (.opcode == 0xea) {
                .nop()
                .opname = "NOP"
            }
            else if (.opcode == 0x9d) {
                .sta(opcode: .opcode)
                .opname = "STA"
            }
            else if (.opcode == 0xaa) {
                .tax()
                .opname = "TAX"
            }
            else if (.opcode == 0x8a) {
                .txa()
                .opname = "TXA"
            }
            else if (.opcode == 0x9a) {
                .txs()
                .opname = "TXS"
            }
            else if (.opcode == 0x98) {
                .tya()
                .opname = "TYA"
            }
            else if (.opcode == 0x9a) {
                .txs()
                .opname = "TXS"
            }
            else if (.opcode == 0x8d) {
                .sta(opcode: .opcode)
                .opname = "STA"
            }
            else if (.opcode == 0x38) {
                .sec()
                .opname = "SEC"
            }
            else if (.opcode == 0x09 or .opcode == 0x05 or .opcode == 0x15 or .opcode == 0x01 or .opcode == 0x11 or .opcode == 0x0d or .opcode == 0x1d or .opcode == 0x19) {
                .ora(opcode: .opcode)
                .opname = "ORA"
            }
            else if (.opcode == 0x29 or .opcode == 0x25 or .opcode == 0x35 or .opcode == 0x21 or .opcode == 0x31 or .opcode == 0x2d or .opcode == 0x3d or .opcode == 0x39) {
                .and_opcode(opcode: .opcode)
                .opname = "AND"
            }
            else if (.opcode == 0x49 or .opcode == 0x45 or .opcode == 0x55 or .opcode == 0x41 or .opcode == 0x51 or .opcode == 0x4d or .opcode == 0x5d or .opcode == 0x59) {
                .eor(opcode: .opcode)
                .opname = "EOR"
            }
            else if (.opcode == 0x69 or .opcode == 0x65 or .opcode == 0x75 or .opcode == 0x61 or .opcode == 0x71 or .opcode == 0x6d or .opcode == 0x7d or .opcode == 0x79) {
                .adc(opcode: .opcode)
                .opname = "ADC"
            }
            else if (.opcode == 0xe9 or .opcode == 0xe5 or .opcode == 0xf5 or .opcode == 0xe1 or .opcode == 0xf1 or .opcode == 0xed or .opcode == 0xfd or .opcode == 0xf9) {
                .sbc(opcode: .opcode)
                .opname = "SBC"
            }
            else if (.opcode == 0xc9 or .opcode == 0xc5 or .opcode == 0xd5 or .opcode == 0xc1 or .opcode == 0xd1 or .opcode == 0xcd or .opcode == 0xdd or .opcode == 0xd9) {
                .cmp(opcode: .opcode)
                .opname = "CMP"
            }
            else if (.opcode == 0x47 or .opcode == 0x57 or .opcode == 0x43 or .opcode == 0x53 or .opcode == 0x4f or .opcode == 0x5f or .opcode == 0x5b) {
                .sre(opcode: .opcode)
                .opname = "SRE"
            }

            print("{:4>04x}  {:0>2x} {}\n", old_pc, .opcode, .opname)
            .debug()
        }
    }

    public function debug(this) {
        print("a: {:0>2x}  x: {:0>2x}  y: {:0>2x}  pc: {:0>4x}  s: {:0>2x}  flags: ", .a, .x, .y, .pc, .s)
        if .negative {
            print("N")
        } else {
            print("-")
        }
        if .overflow {
            print("V")
        } else {
            print("-")
        }
        if .break_flag {
            print("B")
        } else {
            print("-")
        }
        if .decimal {
            print("D")
        } else {
            print("-")
        }
        if .interrupt_disable {
            print("I")
        } else {
            print("-")
        }
        if .zero {
            print("Z")
        } else {
            print("-")
        }
        if .carry {
            print("C")
        } else {
            print("-")
        }
        print("\n")
    }

    // Addressing modes
    function immediate(mut this) -> u8 {
        let arg_address = .pc + 1
        return .system.read_byte(address: arg_address)
    }

    function zero_page(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = .system.read_byte(address: arg_address) as! u16
        return .system.read_byte(address)
    }

    function zero_page_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = .system.read_byte(address: arg_address) as! u16
        .system.write_byte(address, value)
    }

    function zero_page_x(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address) + .x) as! u16
        return .system.read_byte(address)
    }

    function zero_page_x_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address) + .x) as! u16
        .system.write_byte(address, value)
    }

    function zero_page_y(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address) + .y) as! u16
        return .system.read_byte(address)        
    }

    function indirect_zero_page_x(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address) + .x) as! u16
        let new_address = .system.read_word(address)

        return .system.read_byte(address: new_address)
    }

    function indirect_zero_page_y(mut this, check_extra_clock: bool) -> u8 {
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address)) as! u16

        let pre_index = .system.read_word(address)
        let page = pre_index >> 2

        let new_address = pre_index + .y as! u16

        let new_page = new_address >> 2

        // Example of crossing pages:
        // 01ff -> 0200
        if check_extra_clock and page != new_page {
            .clock += 1
        }

        return .system.read_byte(address: new_address)
    }

    function absolute(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = .system.read_word(address: arg_address)
        return .system.read_byte(address)
    }

    function absolute_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = .system.read_word(address: arg_address)
        .system.write_byte(address, value)
    }

    function absolute_x(mut this, check_extra_clock: bool) -> u8 {
        let arg_address = .pc + 1
        mut address = .system.read_word(address: arg_address)

        let page = address >> 2

        address += .x as! u16
        let new_page = address >> 2

        // Example of crossing pages:
        // 01ff -> 0200
        if check_extra_clock and page != new_page {
            .clock += 1
        }

        return .system.read_byte(address)
    }

    function absolute_x_set(mut this, value: u8) {
        let arg_address = .pc + 1
        mut address = .system.read_word(address: arg_address)

        address += .x as! u16

        .system.write_byte(address, value)
    }

    function absolute_y(mut this, check_extra_clock: bool) -> u8 {
        let arg_address = .pc + 1
        mut address = .system.read_word(address: arg_address)
        let page = address >> 2

        address += .y as! u16
        let new_page = address >> 2

        // Example of crossing pages:
        // 01ff -> 0200
        if check_extra_clock and page != new_page {
            .clock += 1
        }

        return .system.read_byte(address)
    }

    function test_nz_flags(mut this, value: u8) {
        .negative = (value & 0x80) == 0x80
        .zero = value == 0
    }

    function ora(mut this, opcode: u8) {
        match opcode {
            0x09u8 => {
                .a = .a | .immediate()
                .clock += 2
                .pc += 2
            }
            0x05u8 => {
                .a = .a | .zero_page()
                .clock += 3
                .pc += 2
            }
            0x15u8 => {
                .a = .a | .zero_page_x()
                .clock += 4
                .pc += 2
            }
            0x01u8 => {
                .a = .a | .indirect_zero_page_x()
                .clock += 6
                .pc += 2
            }
            0x11u8 => {
                .a = .a | .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
            }
            0x0du8 => {
                .a = .a | .absolute()
                .clock += 4
                .pc += 3
            }
            0x1du8 => {
                .a = .a | .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            0x19u8 => {
                .a = .a | .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            else => {
                eprintln("unknown opcode")
            }
        }
        .test_nz_flags(value: .a)
    }

    function and_opcode(mut this, opcode: u8) {
        match opcode {
            0x29u8 => {
                .a = .a & .immediate()
                .clock += 2
                .pc += 2
            }
            0x25u8 => {
                .a = .a & .zero_page()
                .clock += 3
                .pc += 2
            }
            0x35u8 => {
                .a = .a & .zero_page_x()
                .clock += 4
                .pc += 2
            }
            0x21u8 => {
                .a = .a & .indirect_zero_page_x()
                .clock += 6
                .pc += 2
            }
            0x31u8 => {
                .a = .a & .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
            }
            0x2du8 => {
                .a = .a & .absolute()
                .clock += 4
                .pc += 3
            }
            0x3du8 => {
                .a = .a & .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            0x39u8 => {
                .a = .a & .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            else => {
                eprintln("unknown opcode")
            }
        }
        .test_nz_flags(value: .a)
    }

    function eor(mut this, opcode: u8) {
        match opcode {
            0x49u8 => {
                .a = .a ^ .immediate()
                .clock += 2
                .pc += 2
            }
            0x45u8 => {
                .a = .a ^ .zero_page()
                .clock += 3
                .pc += 2
            }
            0x55u8 => {
                .a = .a ^ .zero_page_x()
                .clock += 4
                .pc += 2
            }
            0x41u8 => {
                .a = .a ^ .indirect_zero_page_x()
                .clock += 6
                .pc += 2
            }
            0x51u8 => {
                .a = .a ^ .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
            }
            0x4du8 => {
                .a = .a ^ .absolute()
                .clock += 4
                .pc += 3
            }
            0x5du8 => {
                .a = .a ^ .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            0x59u8 => {
                .a = .a ^ .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            else => {
                eprintln("unknown opcode")
            }
        }
        .test_nz_flags(value: .a)
    }

    function adc(mut this, opcode: u8) {
        let carry_value = match .carry {
            true => 1i16
            else => 0i16
        }

        let intermediate: i16 = match opcode {
            0x69u8 => {
                let tmp = .a as! i16 + .immediate() as! i16 + carry_value
                .clock += 2
                .pc += 2
                yield tmp
            }
            0x65u8 => {
                let tmp = .a as! i16 + .zero_page() as! i16 + carry_value
                .clock += 3
                .pc += 2
                yield tmp
            }
            0x75u8 => {
                let tmp = .a as! i16 + .zero_page_x() as! i16 + carry_value
                .clock += 4
                .pc += 2

                yield tmp
            }
            0x61u8 => {
                let tmp = .a as! i16 + .indirect_zero_page_x() as! i16 + carry_value
                .clock += 6
                .pc += 2

                yield tmp
            }
            0x71u8 => {
                let tmp = .a as! i16 + .indirect_zero_page_y(check_extra_clock: true) as! i16 + carry_value
                .clock += 5
                .pc += 2

                yield tmp
            }
            0x6du8 => {
                let tmp = .a as! i16 + .absolute() as! i16 + carry_value
                .clock += 4
                .pc += 3

                yield tmp
            }
            0x7du8 => {
                let tmp = .a as! i16 + .absolute_x(check_extra_clock: true) as! i16 + carry_value
                .clock += 4
                .pc += 3

                yield tmp
            }
            0x79u8 => {
                let tmp = .a as! i16 + .absolute_y(check_extra_clock: true) as! i16 + carry_value
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }

        // TODO: decimal mode
        .overflow = intermediate > 127i16 or intermediate < -127i16
        .carry = intermediate > 0xff
        .test_nz_flags(value: .a)

        if intermediate < 0 { // heh, trying to figure out jakt :P
            .a = (intermediate + 256i16) as! u8
        } else {
            .a = intermediate as! u8
        }
    }

    function sbc(mut this, opcode: u8) {
        let carry_value = match .carry {
            true => 0i16
            else => 1i16
        }

        let intermediate: i16 = match opcode {
            0xe9u8 => {
                let tmp = .a as! i16 - .immediate() as! i16 - carry_value
                .clock += 2
                .pc += 2

                yield tmp
            }
            0xe5u8 => {
                let tmp = .a as! i16 - .zero_page() as! i16 - carry_value
                .clock += 3
                .pc += 2

                yield tmp
            }
            0xf5u8 => {
                let tmp = .a as! i16 - .zero_page_x() as! i16 - carry_value
                .clock += 4
                .pc += 2

                yield tmp
            }
            0xe1u8 => {
                let tmp = .a as! i16 - .indirect_zero_page_x() as! i16 - carry_value
                .clock += 6
                .pc += 2

                yield tmp
            }
            0xf1u8 => {
                let tmp = .a as! i16 - .indirect_zero_page_y(check_extra_clock: true) as! i16 - carry_value
                .clock += 5
                .pc += 2

                yield tmp
            }
            0xedu8 => {
                let tmp = .a as! i16 - .absolute() as! i16 - carry_value
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xfdu8 => {
                let tmp = .a as! i16 - .absolute_x(check_extra_clock: true) as! i16 - carry_value
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xf9u8 => {
                let tmp = .a as! i16 - .absolute_y(check_extra_clock: true) as! i16 - carry_value
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }
        // TODO: double check the logic here
        .overflow = intermediate < -128i16 or intermediate > 127i16
        .carry = intermediate < 0
        .test_nz_flags(value: .a)
    }

    function cmp(mut this, opcode: u8) {
        let intermediate = match opcode {
            0xc9u8 => {
                let tmp = .a as! i16 - .immediate() as! i16
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xc5u8 => {
                let tmp = .a as! i16 - .zero_page() as! i16
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xd5u8 => {
                let tmp = .a as! i16 - .zero_page_x() as! i16
                .clock += 4
                .pc += 2
                yield tmp
            }
            0xc1u8 => {
                let tmp = .a as! i16 - .indirect_zero_page_x() as! i16
                .clock += 6
                .pc += 2

                yield tmp
            }
            0xd1u8 => {
                let tmp = .a as! i16 - .indirect_zero_page_y(check_extra_clock: true) as! i16
                .clock += 5
                .pc += 2

                yield tmp
            }
            0xcdu8 => {
                let tmp = .a as! i16 - .absolute() as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xddu8 => {
                let tmp = .a as! i16 - .absolute_x(check_extra_clock: true) as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xd9u8 => {
                let tmp = .a as! i16 - .absolute_y(check_extra_clock: true) as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }

        .carry = intermediate >= 0
        .zero = intermediate == 0
        .negative = (intermediate & 0x80) == 0x80
    }

    function cpx(mut this, opcode: u8) {
        let intermediate = match opcode {
            0xe0u8 => {
                let tmp = .x as! i16 - .immediate() as! i16
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xe4u8 => {
                let tmp = .x as! i16 - .zero_page() as! i16
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xecu8 => {
                let tmp = .x as! i16 - .absolute() as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }
        .carry = intermediate >= 0
        .zero = intermediate == 0
        .negative = (intermediate & 0x80) == 0x80
    }

    function cpy(mut this, opcode: u8) {
        let intermediate = match opcode {
            0xc0u8 => {
                let tmp = .y as! i16 - .immediate() as! i16 
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xc4u8 => {
                let tmp = .y as! i16 - .zero_page() as! i16
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xccu8 => {
                let tmp = .y as! i16 - .absolute() as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }
        .carry = intermediate >= 0
        .zero = intermediate == 0
        .negative = (intermediate & 0x80) == 0x80
    }

    function dec(mut this, opcode: u8) {
        match opcode {
            0xc6u8 => {
                mut intermediate = .zero_page()
                intermediate--
                .test_nz_flags(value: intermediate)
                .zero_page_set(value: intermediate)

                .pc += 2
                .clock += 5
            }
            0xd6u8 => {
                mut intermediate = .zero_page_x()
                intermediate--
                .test_nz_flags(value: intermediate)
                .zero_page_x_set(value: intermediate)

                .pc += 2
                .clock += 6
            }
            0xceu8 => {
                mut intermediate = .absolute()
                intermediate--
                .test_nz_flags(value: intermediate)
                .absolute_set(value: intermediate)

                .pc += 3
                .clock += 6
            }
            0xdeu8 => {
                mut intermediate = .absolute_x(check_extra_clock: false)
                intermediate--
                .test_nz_flags(value: intermediate)
                .absolute_x_set(value: intermediate)

                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }            
        }
    }

    function dex(mut this) {
        .pc += 1
        .clock += 2
        .x--
        .test_nz_flags(value: .x)
    }

    function dey(mut this) {
        .pc += 1
        .clock += 2
        .y--
        .test_nz_flags(value: .y)
    }

    function inc(mut this, opcode: u8) {
        match opcode {
            0xe6u8 => {
                mut intermediate = .zero_page()
                intermediate++
                .test_nz_flags(value: intermediate)
                .zero_page_set(value: intermediate)

                .pc += 2
                .clock += 5
            }
            0xf6u8 => {
                mut intermediate = .zero_page_x()
                intermediate++
                .test_nz_flags(value: intermediate)
                .zero_page_x_set(value: intermediate)

                .pc += 2
                .clock += 6
            }
            0xeeu8 => {
                mut intermediate = .absolute()
                intermediate++
                .test_nz_flags(value: intermediate)
                .absolute_set(value: intermediate)

                .pc += 3
                .clock += 6
            }
            0xfeu8 => {
                mut intermediate = .absolute_x(check_extra_clock: false)
                intermediate++
                .test_nz_flags(value: intermediate)
                .absolute_x_set(value: intermediate)

                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }            
        }
    }

    function inx(mut this) {
        .pc += 1
        .clock += 2
        .x++
        .test_nz_flags(value: .x)
    }

    function iny(mut this) {
        .pc += 1
        .clock += 2
        .y++
        .test_nz_flags(value: .y)
    }

    function asl(mut this, opcode: u8) {
        match opcode {
            0x0au8 => {
                .carry = (.a & 0x80) == 0x80
                .a = .a << 1
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x06u8 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x16u8 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x0eu8 => {
                mut tmp = .absolute()
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x1eu8 => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 2
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function rol(mut this, opcode: u8) {
        let carry_value = match .carry {
            true => 1u8
            else => 0u8
        }

        match opcode {
            0x2au8 => {
                .carry = (.a & 0x80) == 0x80
                .a = (.a << 1) + carry_value
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x26u8 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x36u8 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x2eu8 => {
                mut tmp = .absolute()
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x3eu8 => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 2
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function lsr(mut this, opcode: u8) {
        match opcode {
            0x4au8 => {
                .carry = (.a & 0x1) == 0x1
                .a = .a >> 1
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x46u8 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x56u8 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x4eu8 => {
                mut tmp = .absolute()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x5eu8 => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 2
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function sre(mut this, opcode: u8) {
        match opcode {
            0x47u8 => {
                mut tmp = .zero_page() >> 1
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .zero_page()
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x57u8 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .zero_page_x()
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x43u8 => {
                mut tmp = .indirect_zero_page_x()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .indirect_zero_page_x()
                .test_nz_flags(value: tmp)
                .pc += 2
                .clock += 8
            }
            0x53u8 => {
                mut tmp = .indirect_zero_page_y(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .indirect_zero_page_y(check_extra_clock: false)
                .test_nz_flags(value: tmp)
                .pc += 2
                .clock += 8
            }
            0x4fu8 => {
                mut tmp = .absolute()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .absolute()
                .test_nz_flags(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x5fu8 => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .absolute_x(check_extra_clock: false)
                .test_nz_flags(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x5bu8 => {
                mut tmp = .absolute_y(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .a = tmp & 0x00ffu16
                .a = .a ^ .absolute_y(check_extra_clock: false)
                .test_nz_flags(value: tmp)
                .pc += 2
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function ror(mut this, opcode: u8) {
        let carry_value = match .carry {
            true => 0x80u8
            else => 0u8
        }

        match opcode {
            0x6au8 => {
                .carry = (.a & 0x01) == 0x01
                .a = (.a >> 1) + carry_value
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x66u8 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x76u8 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x6eu8 => {
                mut tmp = .absolute()
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x7eu8 => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 2
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }


    public function lda(mut this, opcode: u8) {
        let intermediate: u8 = match opcode {
            0xa9u8 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2

                yield tmp
            }
            0xa5u8 => {
                let tmp = .zero_page()
                .clock += 3
                .pc += 2

                yield tmp
            }
            0xb5u8 => {
                let tmp = .zero_page_x()
                .clock += 4
                .pc += 2

                yield tmp
            }
            0xadu8 => {
                let tmp = .absolute()
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xbdu8 => {
                let tmp = .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xb9u8 => {
                let tmp = .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xa1u8 => {
                let tmp = .indirect_zero_page_x()
                .clock += 6
                .pc += 2

                yield tmp
            }
            0xb1u8 => {
                let tmp = .indirect_zero_page_y(check_extra_clock: true)
                .clock += 6
                .pc += 2

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }
        }

        // set the flags
        .test_nz_flags(value: intermediate)

        .a = intermediate
    }

    public function ldx(mut this, opcode: u8) {
        let intermediate: u8 = match opcode {
            0xa2u8 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2

                yield tmp
            }
            0xa6u8 => {
                let tmp = .zero_page()
                .clock += 3
                .pc += 2

                yield tmp
            }
            0xb6u8 => {
                let tmp = .zero_page_y()
                .clock += 4
                .pc += 2

                yield tmp
            }
            0xaeu8 => {
                let tmp = .absolute()
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xbeu8 => {
                let tmp = .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }           
        }

        // set the flags
        .test_nz_flags(value: intermediate)

        .x = intermediate
    }

    public function ldy(mut this, opcode: u8) {
        let arg_address = .pc + 1

        let intermediate: u8 = match opcode {
            0xa0u8 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2

                yield tmp
            }
            0xa4u8 => {
                let tmp = .zero_page()
                .clock += 3
                .pc += 2

                yield tmp
            }
            0xb4u8 => {
                let tmp = .zero_page_x()
                .clock += 4
                .pc += 2

                yield tmp
            }
            0xacu8 => {
                let tmp = .absolute()
                .clock += 4
                .pc += 3

                yield tmp
            }
            0xbcu8 => {
                let tmp = .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }           
        }

        // set the flags
        .test_nz_flags(value: intermediate)

        .y = intermediate
    }

    function sta(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x85u8 => {
                // Zero page
                .clock += 3
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                .system.write_byte(address: address as! u16, value: .a)
            }
            0x95u8 => {
                // Zero page, x
                .clock += 4
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                // TODO: does this wrap around the zero page?
                .system.write_byte(address: (address + .x) as! u16, value: .a)
            }
            0x8du8 => {
                // Absolute
                .clock += 4
                .pc += 3

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address, value: .a)
            }
            0x9du8 => {
                // Absolute, X
                .clock += 5
                .pc += 3

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address: address + .x as! u16, value: .a)
            }
            0x99u8 => {
                // Absolute, Y
                .clock += 5
                .pc += 3

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address: address + .y as! u16, value: .a)
            }
            0x81u8 => {
                // Indirect, X
                .clock += 6
                .pc += 2

                let address = (.system.read_byte(address: arg_address) + .x) as! u16
                .system.write_byte(address, value: .a)
            }
            0x91u8 => {
                // Indirect, Y
                .clock += 6
                .pc += 2

                let address = (.system.read_byte(address: arg_address)) as! u16

                let pre_index = .system.read_word(address)

                let new_address = pre_index + .y as! u16

                .system.write_byte(address: new_address, value: .a)
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function stx(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x86u8 => {
                // Zero page
                .clock += 3
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                .system.write_byte(address: address as! u16, value: .x)
            }
            0x96u8 => {
                // Zero page, Y
                .clock += 4
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                // TODO: does this wrap around the zero page?
                .system.write_byte(address: (address + .y) as! u16, value: .x)
            }
            0x8eu8 => {
                // Absolute
                .clock += 4
                .pc += 3

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address, value: .x)
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function sty(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x84u8 => {
                // Zero page
                .clock += 3
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                .system.write_byte(address: address as! u16, value: .y)
            }
            0x94u8 => {
                // Zero page, X
                .clock += 4
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                // TODO: does this wrap around the zero page?
                .system.write_byte(address: (address + .x) as! u16, value: .y)
            }
            0x8cu8 => {
                // Absolute
                .clock += 4
                .pc += 3

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address, value: .y)
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function tax(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .a)

        .x = .a
    }

    function txa(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .x)

        .a = .x
    }

    function tay(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .a)

        .y = .a
    }

    function tya(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .y)

        .a = .y
    }

    function tsx(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .s)

        .x = .s
    }

    function txs(mut this) {
        .pc += 1
        .clock += 2

        .s = .x
    }

    function pla(mut this) {
        .pc += 1
        .clock += 4

        .s += 1
        let intermediate = .system.read_byte(address: 0x100u16 + .s as! u16)

        // set the flags
        .test_nz_flags(value: intermediate)
        .a = intermediate
    }

    function pha(mut this) {
        .pc += 1
        .clock += 3

        .system.write_byte(address: 0x100u16 + .s as! u16, value: .a)
        .s -= 1
    }

    function pull_status(mut this) {
        .s += 1
        let intermediate = .system.read_byte(address: 0x100u16 + .s as! u16)

        .negative = ((intermediate & 0x80) == 0x80)
        .overflow = ((intermediate & 0x40) == 0x40)
        .decimal = ((intermediate & 0x08) == 0x08)
        .interrupt_disable = ((intermediate & 0x04) == 0x04)
        .zero = ((intermediate & 0x02) == 0x02)
        .carry = ((intermediate & 0x01) == 0x01)
    }

    function pull_pc(mut this) {
        .s += 1
        .pc = .system.read_word(address: 0x100u16 + .s as! u16)
        .s += 1
    }

    function plp(mut this) {
        .pc += 1
        .clock += 4

        .pull_status()
    }

    function push_status(mut this) {
        mut intermediate = 0u8
        if .negative {
            intermediate |= 0x80
        }
        if .overflow {
            intermediate |= 0x40
        }
        
        intermediate |= 0x20

        if .break_flag {
            intermediate |= 0x10
        }
        if .decimal {
            intermediate |= 0x08
        }
        if .interrupt_disable {
            intermediate |= 0x04
        }
        if .zero {
            intermediate |= 0x02
        }
        if .carry {
            intermediate |= 0x1
        }

        .system.write_byte(address: 0x100u16 + .s as! u16, value: intermediate)
        .s -= 1
    }

    function push_word(mut this, value: u16) {
        // TODO: What order do we push our bytes?

        let first_byte = (value >> 8) as! u8
        .system.write_byte(address: (0x100u16 + .s as! u16), value: first_byte)
        .s -= 1

        let second_byte = (value & 0xff) as! u8
        .system.write_byte(address: (0x100u16 + .s as! u16), value: second_byte)
        .s -= 1
    }

    function php(mut this) {
        .pc += 1
        .clock += 4

        .push_status()
    }

    function branch(mut this) {
        let arg_address = .pc + 1
        let operand: i8 = .system.read_byte(address: arg_address) as! i8
        // The 6502 would have the PC on the next opcode now and everything is
        // based upon that. Lets emulate that which also makes the code look cleaner
        .pc += 2
        
        mut offset: u8 = 0
        mut negative_offset = false
        if (operand < 0) {
            offset = (operand * -1i8) as! u8
            negative_offset = true
        } else {
            offset = operand as! u8
        }
        
        let prev_page = .pc >> 8
        
        // TODO: please add a test for this
        if (negative_offset) {
            .pc = .pc - (offset as! u16)
        } else {
            .pc = .pc + (offset as! u16)
        }
        
        let new_page = .pc >> 8

        if prev_page != new_page {
            .clock += 4
        } else {
            .clock += 3
        }
    }

    function bpl(mut this) {
        if not .negative {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function bmi(mut this) {
        if .negative {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function bvc(mut this) {
        if not .overflow {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function bvs(mut this) {
        if .overflow {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function bcc(mut this) {
        if not .carry {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function bcs(mut this) {
        if .carry {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function bne(mut this) {
        if not .zero {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function beq(mut this) {
        if .zero {
            .branch()
        } else {
            .clock += 2
            .pc += 2
        }
    }

    function brk(mut this) {
        .push_word(value: .pc + 1)

        .clock += 7

        .pc = .system.read_word(address: 0xfffe)
        .break_flag = true
        .interrupt_disable = true
    }

    function rti(mut this) {
        .clock += 6

        .pull_status()
        .pull_pc()
    }

    function jsr(mut this) {
        .push_word(value: .pc + 3)

        .clock += 6

        let arg_address = .pc + 1
        .pc = .system.read_word(address: arg_address)
    }

    function rts(mut this) {
        .clock += 6
        .pull_pc()
    }

    function jmp(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x4cu8 => {
                let address = .system.read_word(address: arg_address)
                .clock += 3
                .pc = address
            }
            0x6cu8 => {
                let indirect_address = .system.read_word(address: arg_address)
                let address = .system.read_word(address: indirect_address)
                .clock += 5
                .pc = address
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function bit(mut this, opcode: u8) {
        let arg_address = .pc + 1

        let value = match opcode {
            0x24u8 => {
                .clock += 3
                .pc += 2

                let address = .system.read_byte(address: arg_address)
                let value = .system.read_byte(address: address as! u16)
                yield value
            }
            0x2cu8 => {
                .clock += 4
                .pc += 3

                let address = .system.read_word(address: arg_address)
                let value = .system.read_byte(address: address)
                yield value
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }
        }

        .zero = (value & .a) == 0
        .negative = (value & 0x80) == 0x80
        .overflow = (value & 0x40) == 0x40
    }

    function clc(mut this) {
        .carry = false
        .pc += 1
        .clock += 2
    }

    function sec(mut this) {
        .carry = true
        .pc += 1
        .clock += 2
    }

    function cld(mut this) {
        .decimal = false
        .pc += 1
        .clock += 2
    }

    function sed(mut this) {
        .decimal = true
        .pc += 1
        .clock += 2
    }

    function cli(mut this) {
        .interrupt_disable = false
        .pc += 1
        .clock += 2
    }

    function sei(mut this) {
        .interrupt_disable = true
        .pc += 1
        .clock += 2
    }

    function clv(mut this) {
        .overflow = false
        .pc += 1
        .clock += 2
    }

    function nop(mut this) {
        .pc += 1
        .clock += 2
    }
}
